dp: 
	exponential -> polynomial
	dfs -> dp
	4 elements:
		state: what does dp[i][j] mean
		function: formula for dp[i][j]
		initialization
		answer: where

iterative deepening dfs: 
    essentially dfs in bfs
    iddfs calls dfs, restricting it from going beyond a given depth
    pseudocode: 
        iddfs(src, tarteg, maxDepth): 
            for limit = (0 -> maxDepth): 
                if dls(src, target, limit): 
                    return true
            return false
        
        // dls stands for depth-limited search
        dls(src, target, limit): 
            if src == target: 
                return true
            if limit <= 0: 
                return false
            for all adjacent i of src: 
                if dls(src, target, limit - 1): 
                    return true
            return false
    note that the nodes of maximum depth are visited once, the second last level are visited twice, and so on
    this is not as costly as the number of nodes in each level grows exponentially

path finding: 
	dijkstra's: 
		O(V ** 2)
		O(E log V) if use heap to determine next vertex to visit, 
			but only appreciably faster on large, sparse graphs
		does not work with negative weight edges
		pseudocode:
			for all nodes i:
				dist[i] = infinity
				visited[i] = false	// not reachable
				parent[i] = null	// no path to vertex yet
			
			dist[source] = 0
			while nodesVisited < graphSize:
				i = unvisited vertex closest to source
				// to find such node i, keep all dist to source in an array(or node)
				assert distance[i] != infinity, "graph not connected"
				visited[i] = true
				
				for all neighbors j of i:
					if dist[i] + weight[i][j] < dist[j]:
						dist[j] = dist[i] + weight[i][j]
						parent[j] = i
	
	floyd-warshall: 
		O(V ** 3)
		finds length of shortest paths between all pairs of vertices
		works with negative weight edges(no negative cycles)
		requires adjacency matrix
		dist[i][j] = weight[i][j] or infinity if no edge connects i and j
		Ɐ pair (u, v), if ∃ w ∋ dist(u -> w -> v) < dist[u][v] then update dist[u][v]
		miraculously requires only 1 iteration if ordered properly
		pseudocode: 
			// dist[i][j] = best known dist(i -> j) so far
			for i = (1 -> n):
				for j = (1 -> n):
					dist[i][j] = weight[i][j]
					// inf if not connected
			
			for k = (1 -> n): 
				for i = (1 -> n): 
					for j = (1 -> n): 
						if dist[i][k] + dist[k][j] < dist[i][j]: 
							dist[i][j] = dist[i][k] + dist[k][j];
		optimizations: 
			due to the symmetric nature of adjacency matrices of undirected graphs, only iterate through half of the matrix
			check if dist[i][k] is inf before proceeding to the j loop
			pseudocode: 
				for i = (1 -> n):
					for j = (1 -> n):
						dist[i][j] = weight[i][j](inf if not connected)
				
				for k = (1 -> n): 
					for i = (1 -> n - 1): 
						if dist[i][k] < inf: 
							for j = (i + 1 -> n): 
								if dist[i][k] + dist[k][j] < dist[i][j]: 
									dist[i][j] = dist[i][k] + dist[k][j];
		
	bfs:
		O(b ** (d + 1)) time & mem (b = avg out-deg, d = depth)
		uses queue
		for unweighted graphs
		if V large E small, much faster than dijkstra's

mst: 
	prim's: 
		O(N ** 2)
		changing any element requires complete recalculation
		does not work with extra constraints(e.g. avg(dist) has to be low)
		works with multiple edges between 2 nodes
		does not extend to directed graphs
		pseudocode: 
			// dist[j] = dist from tree to node j
			// src[j] = node of current mst closest to node j
			for all nodes i: 
				dist[i] = infinity
				inTree[i] = false
				src[i] = null
			
			// add node 1 to tree
			treeSize = 1
			treeCost  0
			inTree[1] = true
			for all neighbors j of node 1: 		// update distances
				dist[j] = weight[1][j]
				src[j] = 1
			
			while treeSize < grashSize: 
				i = node with minimum dist to tree
				assert dist[i] != infinity, "graph not connected"
				
				// add edge (src[i], i) to mst
				treeSize++
				treeCost = treeCost + dist[i]
				inTree[i] = true
				
				// update dist after node i added
				for all neighbors j of i: 
					if dist[j] > weight[i][j]: 
						dist[j] = weight[i][j]
						src[j] = i

pattern searching: 
	kmp algorithm: 
		preprocess pattern to construct auxiliary lps[] of same size as pattern
		lps[i] = longest proper prefix of pattern[0 : i] which is also a suffix of pattern[0 : i]
		e.g. "AAAA" -> [0, 1, 2, 3]; "AABAACAABAA" -> [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]
		using lps to decide next positions: 
			start comparison with pattern[j] with j = 0 at current window of text
			keep incrementing i and j for matching characters text[i] and pattern[j]
			when there is a mismatch: 
				if j is 0, increment i to shift to next window
				otherwise, 
				known(when j > 0): pattern[0 : j - 1] matches text[i - j + 1 : i - 1]
				also from the definition of lps: lps[j - 1] = count of characters of pattern[0 : j - 1] that are both proper prefix and suffix
				conslusion: no need to match the lps[j - 1] characters text[i - j : i - 1] since they match(change only j to lps[j - 1])
			(also when pattern found, reset j to lps[j - 1] by the same reasoning)
		pseudocode: 
			len = 0		// length of previous longest prefix suffix
			i = 1
			lps[0] = 0	// lps[0] is always 0
			
			while i < len(pattern): 
				if pattern[i] == pattern[len]: 
					len++
					lps[i] = len
					i++
				else: 
					if len != 0: 
						len = lps[len - 1]
						// no i increment
					else: 
						lps[i] = len
						i++
			
			i = j = 0
			while i < len(text): 
				if pattern[j] == text[j]: 
					j++
					i++
				if j == len(pattern): 
					// pattern found at index (i - j)
					j = lps[j - 1]
				else if i < len(text) && pattern[j] != text[i]: 
					if j != 0: 
						j = lps[j - 1]
					else: 
						i++

binary trees: 
    e.g. C -> {B -> {A, D -> {E, F}}, G -> H}
    in-order traversal: 
        left sub-tree, root, right sub-tree
        e.g. ABEDFCHG
    pre-order traversal: 
        root, left sub-tree, right sub-tree
        e.g. CBADEFGH
    post-order traversal: 
        left sub-tree, right sub-tree, root
        e.g. AEFDBHGC              

knapsack: 
	given a collection of objects with size and value and the total space available, 
		find the set of objects that maximizes the sum of the value of the set with 
		size constrainted by the limit, the total # or size of any particular item
		used in the set cannot exceed its availability
	fractional knapsack: 
		allowed to place fractional objects in the knapsack
		O(N log N) since must first sort by value to size ratio(O(N ** 2) without sorting)
		rare to have both size and availability
			(do trivial transmation to have all objects of size 1, have availability = original size * availability, 
			and divide the value by original size)
		use greedy algorithm: 
			find the object with highest value to size ratio
			if total capacity remaining >= availability of object, put all in knapsack and iterate
			if total capacity remaining < availability of object, use as much as possible and terminate
	integer knapsack: 
		solvable using dp if knapsack small enough: 
			O(KN), K = size of knapsack, N = sum of availability of objects
			dp[i] = max value that a knapsack of size i can have
			update dp for an object of isze S by traversing in reverse order and seeing if 
				placing the objext into the knapsack of size K yields a better set than the 
				current best knapsack of size K + S
		if knapsack too large to allocate array, use recursive descent since NP-complete
		if all sizes are same, solve greedily, picking the objects in decreasing value order until knapsack full
		if values are all 1, solve greedily, picking the objects in increasing size order until knapsack full
	multiple knapsack: 
		more than 1 knapsack is to be filled(multiple integer knapsacks)
		state space is too large for dp, use recursive descent
		if values are all 1 && max # of objects that can be placed in all knapsacks is n, 
			then there is a solution which uses n smallest objects
			
eulerian tour: 
	O(m + n) (m = # of edges, n = # of nodes) if graph in adjacency matrix form
	given an undirected graph, find a path which uses every edge once
	eulerian circuit: starts and ends on the same vertex
	a graph has an eulerian path: 
		iff connected
		iff every node except 2 has even degree(of the two odd degree nodes, one is start and the other is end)
	a graph has an eulerian circuit:
		iff connected
		iff every node has even degree
	pseudocode: 
		circuitPos = 0
		findCircuit(node 1)
		
		findCircuit(node i): 
			if i has no neighbors: 
				circuit[circuitPos++] = i
			else: 
				while i has neighbors: 
					pick random neighbor j of i
					// for multiple edges between the same nodes, subtract 1 from the adjacency matrix
					deleteEdges(i, j)
					findCircuit(j)
				circuit[circuitPos++] = i
	to find eulerian tour, findCircuit(one of the odd degree nodes)
	may overflow runtime stack with larger graphs thus use own stack
	works for multple edges between the same nodes and self-loops(1 indegree + 1 outdegree)
	a directed graph has a eulerian circuit if strongly connected and indegree == outdegree for each node, except traverse the arcs in reverse order

computational geometry: 
	dot product = |u||v|cos(theta)
	|cross product| = |u||v|sin(theta)
	area of polygon = (1 / 2)|x1 x2 ... xn|
	                         |y1 y2 ... yn| where the determinant = x1y2 + x2y2 + ... + xny1 - y1x2 - y2x3 - ... - ynx1
    dist from point to line d(P, AB) = |(P - A) x (B - A)| / |B - A|( = |AB||AP|sin(theta) / |AB| = |AP|sin(theta))
    check if points C and D are on the same side of line AB(for 2 dimensions): 
        |(B - A) x (C - A)| * |(B - A) x (D - A)| > 0 => (cross products have same signs)
        note that the magnitude of the cross products are their z values in this case
    check if a point A is in a triangle: 
        find point B which is in the triangle(e.g. average of the 3 vertices)
        check if A is on the same side as B for all 3 edges
        same works for convex polygons
    check if a collection of points are coplanar: 
        select points A, B, and C
        the points are coplanar if for any other point D, the triple product of (B - A), (C - A), and (D - A) is 0
        (((B - A) x (C - A)) · (D - A) == 0)
    check if 2 line segments are parallel: 
        create vectors and see if the cross product == 0
    check if 2 lines intersect: 
        in 2 dimensions, two lines intersect if they are not parallel
        in 3 dimensions, two lines AB and CD intersect if they are not parallel and A, B, C, and D are coplanar
    check if 2 line segments intersect: 
        in 2 dimensions, two line segments AB and CD intersect iff A and B are on opposite sides of line CD, while C and D are on opposite sides of line AB
        in 3 dimensions, solve for i and j in: 
            Ax + (Bx - Ax)i = Cx + (Dx - Cx)j
            Ay + (By - Ay)i = Cy + (Dy - Cy)j
            Az + (Bz - Az)i = Cz + (Dz - Cz)j
            if 0 <= i, j <= 1, then the intersection is at (Ax + (Bx - Ax)i, Ay + (By - Ay)i, Az + (Bz - Az)i)
    find intersection of 2 lines: 
        solve the above set of equations(discard the z equation for 2 dimensions)
    check if a polygon is convex: 
        traverse the vertices in clock-wise order, for each triplet of consecutive points A, B, and C, 
        calculate (B - A) x (C - A)
        if the z component of each of the cross producs is positive, the polygon is convex
    check if a point is within a nonconvex polygon: 
        make a ray from the point in a random direction and count the # of times it intersects the polygon
        if the ray intersects the polygon at a vertex or along an edge, pick a new direction
        the point is within the polygon iff the ray intersects the polygon an odd # of times
        this method extends to 3 dimsneions, but the ray can only intersect at faces
    geometric methodologies: 
        monte carlo: 
            random sampling for probability
            e.g. area of a figure: 
                decide a bounding box and estimate the probability of hitting the figure at a random point
        partitioning: 
            method to improve speed of a geometric algorithm
            divide the plane up into sections(usually by a grid, but sometimes into radial sections and etc.)
            bucket objects into appropriate sections
            e.g. searching for objects within some figure: 
                only sections which have a nonzero intersection with the figure need to be examined

network flow: 
    given a connected integer weighted directed graph along with a source node and a sink node
    let c(u, v) be the weight of arc (u, v), which is the capacity and let f(u, v) be the flow of arc (u, v)
    a flow through the graph is constructed by assigning integer amount of flow through each edge such that: 
        f(u, v) <= c(u, v)
        sum(f(u, x)) == sum(f(x, v)) where (u, x) are in-arcs of x and (x, v) are out-arcs of x
    maximize the total weight of the out-arcs of the source - the total weight of the in-arcs of the source: 
        start every arc having weight equal to the capacity(beginning weight)
        the weight correspond to the amount of capacity still unused in that arc
        given the current graph, find path from source to sink arcs that all have non-zero weight
        let pathCap = maximum flow across the path(== min(c(u, v) Ɐ (u, v) along the path))
        reduce the weight of each arc along the path by pathCap and add pathCap to the weight of the reverse arc of each arc along the path
        pseudocode(algorithm from USACO Training, O(FM) where F = maximum flow, M = # of arcs): 
            // the algorithm is essentially constructing the residual network(leftover capacity for both directions between vertices) and searching for augmenting paths
            // the termination of the algorithm is guaranteed for integer weights since the flow is increased every iteration
            if src == sink: 
                totalFlow = inf
                return
                
            while true: 
                // find path with highest capacity from source to sink
                // uses a modified dijkstra's algorithm
                for all nodes i: 
                    prevNode[i] = null
                    flow[i] = 0
                    visited[i] = false
                flow[src] = inf
                
                whlie true: 
                    maxFlow = 0
                    maxLoc = null
                    for all nodes i: 
                        // find unvisited node with highest capacity
                        if flow(i) > maxFlow && !visited(i): 
                            maxFlow = flow(i)
                            maxLoc = i
                    if maxLoc == null: 
                        break
                    if maxLoc == sink: 
                        break
                    visited[maxLoc] = true
                    // update neighbors
                    for all neighbors i of maxLoc: 
                        if flow[i] < min(maxFlow, capacity(maxLoc, i)): 
                            prevNode[i] = maxLoc
                            flow[i] = min(maxFlow, capacity(maxLoc, i))
                    
                // no path
                if maxLoc == null: 
                    break
                
                pathCapacity = flow[sink]
                totalFlow += pathCapacity
                
                // add flow to network, update capacity
                curNode = sink
                // for each arc, prevNode[curNode], curNode on path: 
                while curNode != src: 
                    nextNode = prevNode(curNode)
                    capacity(nextNode, curNode) -= pathCapacity
                    capacity(curNode, nextNode) += pathCapacity
                    curNode = nextNode
        undirected graphs: 
            expand the edge as 2 arcs in opposite directions
        limit amount of traffic through any node: 
            split node into 2, an in-node and an out-node
            put in-arcs into in-node and out-arcs into out-node
            place arc from in-node to out-node with capacity of the node
        multiple arcs that are between the same nodes: 
            add up the weights of the arcs in 1 arc and discard all others
        multiple sources and sinks: 
            create virtual source and virtual sink
            place arcs from virtual source to each source
            place arcs from each sink to virtual sink
            make each added arcs have infinite capacity
        real-valued weights: 
            the algorithm above no longer guarantees termination, but will asymptotically approach the maximum
        alternate problems: 
            maximum matching: 
                given 2 sets of objects A and B, match as many individual A objects with individual B objects as possible
                subject to the constraint that only certain pairs are possible
                create source and add arc with capacity 1 from source to each A object
                create sink with arc from each B object to it with capacity 1
                if object Ai and Bj are allowed to be matched together, add arc from Ai to Bj with capacity 1
                run algorithm and determine arcs used between A objects and B objects
            minimum cut: 
                given a weighted undirected graph, find the set of edges with minimum total weight such that it separates two given nodes
                minimum total weight is the flow between the two nodes
                to determine the path, try removing each edge in increasing weight order, and seeing if it reduces the network flow
                if removing the edge does reduce the network flow, it should reduce the flow by the capacity of the edge
                the first edge that reduces the flow is a memter of the minimum cut, iterate on the graph without that edge
                max-flow min-cut theorem: 
                    in a flow network, the maximum amount of flow passing from the source to the sink is equal to the total weight of the edges in the minimum cut
                    proof: 
                        flow <= cut since cut is the capacity and flow <= capacity
                        constructing a flow is constructing a cut: 
                            when maximum flow is reached, there would not be an augmenting path from s(source) to t(sink) since otherwise the flow can be further augmented
                            let set S be the set of vertices that can be reached from s, set T be the set of other vertices
                            the arcs from S to T must be full, otherwise the flow can be augmented
                        max-flow == min-cut because any 1 flow <= any 1 cut: 
                            any F <= Fmax <= Cmin <= any C

big nums: 
    structure: 
        list of numbers + sign
        upper bound known: array
        upper bound unknown: linked list(deque)
        store the number in base b, let a0, a1, ..., an be the digits stored
        value = ((-1) ** sign) * (a0 + a1(b ** 1) + a2(b ** 2) + ... + an(b ** n))
        note that a0, a1, ..., an have to be within [0, b - 1]
        b is generally selected to be a power of 10 for easy display of the number
    operations: 
        make sure that every addition and multiplication will not result in an overflow
        comparison: 
            pseudocode: 
                // sgn(A) == 0 => positive
                // sgn(A) == 1 => negative
                // A.size = number of digits of A
                if sgn(A) < sgn(B): 
                    return "A < B"
                else if sgn(A) > sgn(B): 
                    return "A > B"
                else: 
                    for i = (max(A.size, B.size) -> 0): 
                        if a[i] > b[i]: 
                            if sgn(A) == 0: 
                                return "A > B"
                            else: 
                                return "A < B"
                        else if a[i] < b[i]: 
                            if sgn(A) == 0: 
                                return "A < B"
                            else: 
                                return "A > B"
                    return "A == B"
        addition: 
            if numbers have opposite signs, calculate which is larger in absolute value, subtract the smaller from the larger, and set the sign to be the same as the larger number
            otherwise, add numbers from 0 to max(A.size, B.size) while maintaining a carry bit
            pseudocode: 
                absoluteSubtract(A, B, C): 
                    borrow = 0
                    for pos = (0 -> max(A.size, B.size)): 
                        C[pos] = A[pos] - B[pos] - borrow
                        if C[pos] < 0: 
                            C[pos] = C[pos] + base
                            borrow = 1
                        else: 
                            borrow = 0
                        // it has to be done this way to handle the case of subtracting two very close numbers
                        // e.g. 7658493 - 7658492
                        if C[pos] != 0: 
                            C.size = pos
                        assert borrow == 0, "|B| > |A|"
                
                absoluteAdd(A, B, C): 
                    carry = 0
                    for pos = (0 -> max(A.size, B.size)): 
                        C[pos] = A[pos] + B[pos] + carry
                        carry = C[pos] / base
                        C[pos] %= base
                    if carry != 0: 
                        // check for overflow
                        C[max(A.size, B.size) + 1] = carry
                        C.size = max(A.size, B.size) + 1
                    else: 
                        C.size = max(A.size, B.size)
                
                add(A, B, C): 
                    if sgn(A) == sgn(B): 
                        absoluteAdd(A, B, C)
                        sgn(C) = sgn(A)
                    else: 
                        if A > B: 
                            absoluteSubtract(A, B, C)
                            sgn(C) = sgn(A)
                        else: 
                            absoluteSubtract(A, B, C)
                            sgn(C) = sgn(B)
        subtraction: 
            A - B = A + (-B)
        multiplication by scalar: 
            pseudocode: 
                if s < 0: 
                    sgn(B) = 1 - sgn(A)
                    s = -s
                else: 
                    sgn(B) = sgn(A)
                carry = 0
                for pos = (0 -> A.size): 
                    B[pos] = A[pos] * s + carry
                    carry = B[pos] / base
                    B[pos] %= base
                pos = A.size + 1
                while carry != 0: 
                    // check for overflow
                    B[pos] = carry % base
                    carry /= base
                    pos++
                B.size = pos - 1
        multiplication of 2 bignums: 
            multiply one of the numbers by each digit of the other, and add it with appropriate offset to a running total
            pseudocode: 
                multiplyAndAdd(A, s, offset, C): 
                    carry = 0
                    for pos = (0 -> A.size): 
                        C[pos + offset] += A[pos] * s + carry
                        carry = C[pos + offset] / base
                        C[pos + offset] %= base
                    pos = A.size + offset + 1
                    while carry != 0: 
                        // check for overflow
                        C[pos] += carry
                        carry = C[pos] / base
                        C[pos] %= base
                        pos++
                    if C.size < pos - 1: 
                        C.size = pos - 1
                
                multiply(A, B, C): 
                    for pos = (0 -> B.size): 
                        multiplyAndAdd(A, B[pos], pos, C)
                    sgn(C) = (sgn(A) + sgn(B)) % 2
                division by scalar: 
                    pseudocode: 
                        divideByScalar(A, s, C): 
                            rem = 0
                            C.size = 0
                            for pos = (A.size -> 0): 
                                rem = rem * b + A[pos]
                                C[pos] = rem / s
                                if C[pos] > 0 && pos > C.size: 
                                    C.size = pos
                                rem %= s
                        // rem is remainder of the division
                division by bignum: 
                    pseudocode: 
                        divide(A, B, C): 
                            bignum rem = 0
                            for pos = (A.size -> 0): 
                                multiplyByScalarInPlace(rem, B)
                                addScalarInPlace(rem, A[pos])
                                C[pos] = 0
                                while rem > B: 
                                    C[pos]++
                                    subtractInPlace(rem, B)
                                if C[pos] > 0 && pos > C.size: 
                                    C.size = pos